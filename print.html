<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The IOTA Protocol RFC Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0005-white-flag/0005-white-flag.html">0005-white-flag</a></li><li class="chapter-item expanded "><a href="0008-uniform-random-tip-selection/0008-uniform-random-tip-selection.html">0008-uniform-random-tip-selection</a></li><li class="chapter-item expanded "><a href="0012-milestone-merkle-validation/0012-milestone-merkle-validation.html">0012-milestone-merkle-validation</a></li><li class="chapter-item expanded "><a href="0015-binary-to-ternary-encoding/0015-binary-to-ternary-encoding.html">0015-binary-to-ternary-encoding</a></li><li class="chapter-item expanded "><a href="0017-tangle-message/0017-tangle-message.html">0017-tangle-message</a></li><li class="chapter-item expanded "><a href="0018-transaction-payload/0018-transaction-payload.html">0018-transaction-payload</a></li><li class="chapter-item expanded "><a href="0019-milestone-payload/0019-milestone-payload.html">0019-milestone-payload</a></li><li class="chapter-item expanded "><a href="0020-bech32-address-format/0020-bech32-address-format.html">0020-bech32-address-format</a></li><li class="chapter-item expanded "><a href="0024-message-pow/0024-message-pow.html">0024-message-pow</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The IOTA Protocol RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="iota-protocol-rfcs"><a class="header" href="#iota-protocol-rfcs">IOTA Protocol RFCs</a></h1>
<blockquote>
<p>This process is modelled after the approach taken by the Rust programming
language, see <a href="https://github.com/rust-lang/rfcs">Rust RFC repository</a> for more information. Also see
<a href="https://github.com/maidsafe/rfcs">maidsafe's RFC process</a> for another project in the crypto space.
Our approach is taken and adapted from these.</p>
</blockquote>
<p>To propose changes to the IOTA protocol, we ask for these to go through a more
organized design process --- an <em>RFC</em> (request for comments) process. The goal
is to organize work between the different developers affiliated with the IOTA
Foundation, and the wider open source community. We want to vet the ideas early
on, get and give feedback, and only then start the implementation once the
biggest questions are taken care of.</p>
<h2 id="what-is-substantial-and-when-to-follow-this-process"><a class="header" href="#what-is-substantial-and-when-to-follow-this-process">What is <em>substantial</em> and when to follow this process</a></h2>
<p>You need to follow this process if you want to propose changes that affect the IOTA protocol. These are changes that would affect any underlying node software.</p>
<ul>
<li>Anything that constitutes a breaking change to the protocol that would have to be adopted by each node software operating on the network in order to keep participating in the network.</li>
<li>Any proposed additional change to the protocol that could be adopted by any node software.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Changes to the individual node software implementations - if that is the case, follow the IRI and Bee RFC processes.</li>
</ul>
<h2 id="the-workflow-of-the-rfc-process"><a class="header" href="#the-workflow-of-the-rfc-process">The workflow of the RFC process</a></h2>
<p>To make a change to the IOTA protocol, one must first get the RFC
merged into the RFC repository as a markdown file. At that point the RFC is
&quot;active&quot; and may be implemented with the goal of eventual inclusion into any node software. </p>
<ul>
<li>Fork the RFC repository</li>
<li>Copy <code>0000-template.md</code> to <code>text/0000-my-feature/0000-my-feature.md</code> (where
&quot;my-feature&quot; is descriptive; don't assign an RFC number yet; extra documents
such as graphics or diagrams go into the new folder).</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present
convincing motivation, demonstrate lack of understanding of the design's
impact, or are disingenuous about the drawbacks or alternatives tend to be
poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design feedback
from the larger community, and the author should be prepared to revise it in
response.</li>
<li>Each pull request will be labeled with the most relevant sub-team, which will
lead to its being triaged by that team in a future meeting and assigned to
a member of the subteam.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are much
more likely to make progress than those that don't receive any comments. Feel
free to reach out to the RFC assignee in particular to get help identifying
stakeholders and obstacles.</li>
<li>The sub-team will discuss the RFC pull request, as much as possible in the
comment thread of the pull request itself. Offline discussion will be
summarized on the pull request comment thread.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives and
drawbacks are shown. You can make edits, big and small, to the RFC to clarify
or change the design, but make changes as new commits to the pull request,
and leave a comment on the pull request explaining your changes.
Specifically, do not squash or rebase commits after they are visible on the
pull request.</li>
<li>At some point, a member of the subteam will propose a &quot;motion for final
comment period&quot; (FCP), along with a disposition for the RFC (merge, close, or
postpone).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that
the subteam is in a position to make a decision. That does not require
consensus amongst all participants in the RFC thread (which is usually
impossible). However, the argument supporting the disposition on the RFC
needs to have already been clearly articulated, and there should not be
a strong consensus against that position outside of the subteam. Subteam
members use their best judgment in taking this step, and the FCP itself
ensures there is ample time and notification for stakeholders to push
back if it is made prematurely.</li>
<li>For RFCs with lengthy discussion, the motion to FCP is usually preceded
by a summary comment trying to lay out the current state of the
discussion and major tradeoffs/points of disagreement.</li>
<li>Before actually entering FCP, all members of the subteam must sign off;
this is often the point at which many subteam members first review the
RFC in full depth.</li>
</ul>
</li>
<li>The FCP lasts ten calendar days, so that it is open for at least 5 business
days. It is also advertised widely, e.g. on discord or in a blog post. This
way all stakeholders have a chance to lodge any final objections before
a decision is reached.</li>
<li>In most cases, the FCP period is quiet, and the RFC is either merged or
closed. However, sometimes substantial new arguments or ideas are raised, the
FCP is canceled, and the RFC goes back into development mode.</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes active then authors may implement it and submit the feature
as a pull request to the repo. Being &quot;active&quot; is not a rubber stamp and in
particular still does not mean the feature will ultimately be merged. It does
mean that in principle all the major stakeholders have agreed to the feature
and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot;
implies nothing about what priority is assigned to its implementation, nor does
it imply anything about whether a developer has been assigned the task of
implementing the feature. While it is not necessary that the author of the RFC
also write the implementation, it is by far the most effective way to see an
RFC through to completion. Authors should not expect that other project
developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to active RFCs can be done in follow up PRs. We strive to write
each RFC in a manner that it will reflect the final design of the feature,
however, the nature of the process means that we cannot expect every merged RFC
to actually reflect what the end result will be at the time of the next major
release. We therefore try to keep each RFC document somewhat in sync with the
network feature as planned, tracking such changes via followup pull requests to
the document.</p>
<p>An RFC that makes it through the entire process to implementation is considered
&quot;implemented&quot; and is moved to the &quot;implemented&quot; folder. An RFC that fails after
becoming active is &quot;rejected&quot; and moves to the &quot;rejected&quot; folder.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the sub-team may schedule meetings with the
author and/or relevant stakeholders to discuss the issues in greater detail,
and in some cases the topic may be discussed at a sub-team meeting. In either
case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>A sub-team makes final decisions about RFCs after the benefits and drawbacks
are well understood. These decisions can be made at any time, but the sub-team
will regularly issue decisions. When a decision is made, the RFC pull request
will either be merged or closed. In either case, if the reasoning is not clear
from the discussion in thread, the sub-team will add a comment describing the
rationale for the decision.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right
away. Other accepted RFCs can represent features that can wait until some
arbitrary developer feels like doing the work. Every accepted RFC has an
associated issue tracking its implementation in the affected repositories.
Therefore, the associated issue can be assigned a priority via the triage
process that the team uses for all issues in the appropriate repositories.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC
author (like any other developer) is welcome to post an implementation for
review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but
cannot determine if someone else is already working on it, feel free to ask
(e.g. by leaving a comment on the associated issue).</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC postponement</a></h2>
<p>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are
closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is
marked as such because we want neither to think about evaluating the proposal
nor about implementing the described feature until some time in the future, and
we believe that we can afford to wait until then to do so. Historically,
&quot;postponed&quot; was used to postpone features until after 1.0. Postponed pull
requests may be re-opened when the time is right. We don't have any formal
process for that, you should ask members of the relevant sub-team.</p>
<p>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an
informal first round of evaluation, namely the round of &quot;do we think we would
ever possibly consider making this change, as outlined in the RFC pull request,
or some semi-obvious variation of it.&quot; (When the answer to the latter question
is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</p>
<h2 id="help-this-is-all-too-informal"><a class="header" href="#help-this-is-all-too-informal">Help! This is all too informal</a></h2>
<p>The process is intended to be as lightweight as reasonable for the present
circumstances. As usual, we are trying to let the process be driven by
consensus and community norms, not impose more structure than necessary.</p>
<h1 id="contributions-license-copyright"><a class="header" href="#contributions-license-copyright">Contributions, license, copyright</a></h1>
<p>This Protocol network library is licensed under Apache License, Version 2.0,
(<a href="https://github.com/iotaledger/bee-rfcs/blob/master/LICENSE-APACHE">LICENSE-APACHE</a> or http://www.apache.org/licenses/LICENSE-2.0). Any
contribution intentionally submitted for inclusion in the work by you, as
defined in the Apache-2.0 license, shall be licensed as above, without any
additional terms or conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>white-flag</code></li>
<li>Start date: 2020-03-06</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/5">iotaledger/protocol-rfcs#0005</a>, <a href="https://github.com/iotaledger/protocol-rfcs/pull/30">iotaledger/protocol-rfcs#0030</a></li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This RFC is part of a set of protocol changes, <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, aiming at improving the
network before <a href="https://coordicide.iota.org/">Coordicide</a> is complete.</p>
<p>The feature presented in this RFC, White Flag, allows milestones to confirm conflicting messages by enforcing
deterministic ordering of the Tangle and applying only the first message(s) that will not violate the ledger state.</p>
<p>The content of this RFC is based on <a href="https://iota.cafe/t/conflict-white-flag-mitigate-conflict-spamming-by-ignoring-conflicts/233">Conflict white flag: Mitigate conflict spamming by ignoring conflicts</a>.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<ul>
<li>Eliminates the <a href="https://iota.cafe/t/conflict-spamming-attack/232">Conflict spamming attack</a>;</li>
<li>As conflicts are ignored in the balance computation, they do not need to be considered during tip selection of the
nodes allowing much easier tip selection algorithms leading to increased TPS;</li>
<li>By using this approach in combination with an appropriate TSA, during regular use, no honest message will ever
require re-attaching leading to increased CTPS;</li>
<li>Does not come with added computation complexity by integrating nicely into already existing algorithms;</li>
</ul>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h1>
<p>First, let us define what it means for a message A to be:</p>
<ul>
<li>referenced (indirectly or directly) by message B: A is contained in the past cone of B;</li>
<li>confirmed: A is referenced by a milestone;</li>
<li>applied: A is confirmed and applied to the ledger state;</li>
<li>ignored: A is confirmed but not applied because it is semantically invalid;</li>
<li>conflicting: A would lead to an invalid ledger state if applied;</li>
</ul>
<p>In case of conflicting messages with White Flag, a node applies only one message to the ledger state and ignores
all the others. For this to work, all the nodes need to be sure they are all applying the same message; hence, the
need for a deterministic ordering of the Tangle.</p>
<p>First, this RFC proposes a deterministic ordering of the Tangle, then it explains which message is selected in case
of conflicts.</p>
<p><strong>Note: The past-cone of milestone can only contain syntactically valid messages. If an invalid message is encountered,
operations must be stopped immediately.</strong></p>
<h2 id="deterministically-ordering-the-tangle"><a class="header" href="#deterministically-ordering-the-tangle">Deterministically ordering the Tangle</a></h2>
<p>When a new milestone is broadcasted to the network, nodes will need to order the set of messages it confirms.</p>
<p>A subset of the Tangle can be ordered depending on many of its properties (e.g. alphanumeric sort of the message
hashes); however, to compute the ledger state, a graph traversal has to be done so it can be used to order the messages
in a deterministic order with no extra overhead.</p>
<p>This ordering is then defined as a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological ordering</a> because
it respects the dependency of messages, ensuring that parents of a message are applied before it.
Since there are multiple valid topological orders for the same graph and, to avoid conflicting ledger states, it
is required that all nodes apply messages in the exact same order.</p>
<p>For this reason, this RFC proposes an order that has to be rigorously followed by all node implementations.
This order is the topological ordering generated by a post-order <a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-First Search (DFS)</a>
starting from a milestone message, going through its parents (in the order they appear in the message) and finally
analysing the current message. Since only a subset of messages is considered, the stopping condition of this DFS is
reaching messages that are already confirmed by another milestone.</p>
<h2 id="applying-first-messages-that-does-not-violate-the-ledger-state"><a class="header" href="#applying-first-messages-that-does-not-violate-the-ledger-state">Applying first message(s) that does not violate the ledger state</a></h2>
<p>If a conflict is occurring in the set of messages confirmed by a milestone, nodes have to apply the first - with regards
to the order previously proposed - of the conflicting messages to the ledger and ignore all the others.</p>
<p>Once a message is marked as ignored, this is final and cannot be changed by a later milestone.</p>
<p>Since the ledger state is maintained from one milestone to another, a message conflicting with a message already
confirmed by a previous milestone would also be ignored.</p>
<h2 id="pseudo-code"><a class="header" href="#pseudo-code">Pseudo-code</a></h2>
<p>The following algorithm describes the process of updating the ledger state which is usually triggered by the arrival of
a new milestone confirming many new messages.</p>
<p>Pseudo-code means that implementation details such as types, parameters, ..., are not important but that the logic has
to be followed with care when implementing a node to avoid differences in the ledger state.</p>
<pre><code>update_ledger_state(ledger, milestone, solid_entry_points) {
    s = new Stack()
    visited = new Set()

    s.push(milestone)

    while (!s.is_empty()) {
        curr = s.peek()
        next = null

        // Look for the first eligible parent that was not already visited
        for parent in curr.parents {
          if (!solid_entry_points.contains(parent) &amp;&amp; !parent.confirmed &amp;&amp; !visited.contains(parent)) {
            next = parent
            break
          }
        }

        // All parents have been visited, apply and visit the current message
        if next == null {
          ledger.apply(curr)
          visited.add(curr)
          s.pop()
        }
        // Otherwise, go to the parent
        else {
          s.push(next)
        }
    }
}
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li><code>solid_entry_points</code> is a set of hashes that are considered solid even though we do not have them or their past in
a database. They often come from a snapshot file and allow a node to solidify without needing the full tangle history.
The hash of the genesis message is also a solid entry point.</li>
<li><code>confirmation_index</code> is the index of the milestone that confirmed the message.</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>In this example, there are 26 messages labeled from <code>A</code> to <code>Z</code>.
The set of red messages <code>{A, B, C, E, F, H}</code> is confirmed by milestone <code>H</code>.
The set of purple messages <code>{D, G, J, L, M, N, K, I, O, S, R, V}</code> is confirmed by milestone <code>V</code>.
The set of blue messages <code>{Q, U, X, Y, Z, W, T, P}</code> is confirmed by another milestone.</p>
<p><img src="0005-white-flag/img/tangle.svg" alt="" /></p>
<p>Applying the previously shown algorithm on the purple set produces the topological order
<code>{D, G, J, L, M, R, I, K, N O, S, V}</code>.</p>
<p><img src="0005-white-flag/img/tangle-conflict.svg" alt="" /></p>
<p>Here, message <code>G</code> and message <code>O</code>, both confirmed by milestone <code>V</code>, are conflicting. Since in the topological order just
produced, <code>G</code> appears before <code>O</code>, <code>G</code> is applied to the ledger and <code>O</code> is ignored.</p>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<ul>
<li>The ledger state is now only well-defined at milestones, meaning that we have to wait until each milestone is
issued in order to confirm a spend;</li>
<li>Everything that is seen is now part of the Tangle, including double-spend attempts, meaning that malicious data will
now be saved as part of the consensus set of the Tangle;</li>
<li>To prove that a specific (non-milestone) message is valid, it is no longer sufficient to just provide the &quot;path&quot;
to its confirming milestone, but instead all messages in its past cone.</li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>The main alternative to White Flag is what has been done so far i.e. not allowing conflicting messages confirmation.
As explained in this RFC, this comes with added complexity when performing a Tip Selection Algorithm because a node has
to constantly check for ledger inconsistencies.</p>
<p>As part of Chrysalis and coupled with an adequate Tip Selection Algorithm, White Flag is an improvement of the network
by allowing a potential increase of TPS/CTPS.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<p>A node consumes and produces snapshot files and bases the computation of its ledger state on them. In the current
network, if one of these files was tampered with and fed to a node, it would eventually lead to an invalid ledger state
where a message confirmed by a milestone would actually be a double spend. This situation would be detected by the node
and it would stop its activities as a security measure. However, with White Flag, such messages would be confirmed by
milestones but ignored by the node, the fake snapshot then going unnoticed. The ledger state would then become more and
more corrupted and the view of the balances completely wrong, errors just accumulating over time. The need for a
snapshot verification mechanism is then amplified by the implementation of White Flag. This mechanism being out of the
scope of this RFC, it will be described in another RFC.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>uniform-random-tip-selection</code></li>
<li>Start date: 2020-03-09</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/0008">iotaledger/protocol-rfcs#0008</a></li>
</ul>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Weighted Uniform Random Tip Selection on a subset enables a node to perform fast tip-selection to increase message throughput.
The algorithm selects tips which are non-lazy to maximize confirmation rate.</p>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<p>Because of the <code>white-flag</code> confirmation algorithm, it is no longer necessary to perform complex
tip-selection which evaluates ledger mutations while walking. Therefore, a more simple, better 
performing algorithm can be used to select tips, which in turn increases overall message throughput.</p>
<p>To maximize confirmation rate however, the algorithm needs to return tips which are <code>non-lazy</code>.
Non-lazy in this context means that a tip does not attach to a cone of messages which is too far
in the past. Such a cone is likely to be already confirmed and does not contribute to the
rate of newly confirmed messages when a milestone is issued.</p>
<h1 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h1>
<p>Definitions:</p>
<ul>
<li><code>Direct Approvers</code> - The set of messages which directly approve a given message.</li>
<li><code>Approvee</code> - The directly approved message of a given message.</li>
<li><code>Solid Message</code> - A message that its past cone is known to the node.</li>
<li><code>Valid Message</code>- A message which is syntactically valid.</li>
<li><code>Tip</code> - A valid solid message that doesn't have approvers. Its past cone contains only valid messages.</li>
<li><code>Score</code> - An integer assigned to a <code>tip</code>. The tip selection algorithm uses it to determine how to select tips.</li>
<li><code>Confirmed Root Message</code> - The set of first seen messages which are confirmed by a previous milestone 
when we walk the past cone of a given message. The walk stops on a confirmed message.<br />
Note that the red marked milestone is also a <code>Confirmed Root Message</code>.
<img src="0008-uniform-random-tip-selection/images/cnf_tx_roots.PNG" alt="sdf" /></li>
<li><code>Message Snapshot Index (MSI)</code> defines the index of the milestone which confirmed a given message.</li>
<li><code>Oldest Message Root Snapshot Index (OMRSI)</code> defines the lowest milestone index of a set of
<code>Confirmed Root Messages</code> of a given messages.</li>
<li><code>Youngest Message Root Snapshot Index (YMRSI)</code> defines the highest milestone index of a set of
<code>Confirmed Root Messages</code> of a given message.</li>
<li><code>Latest Solid Milestone Index (LSMI)</code> the index of the latest solid milestone.</li>
<li><code>Below Max Depth (BMD)</code> defines a threshold value up on which it is decided on whether a message is not
relevant in relation to the recent parts of the Tangle. The current <code>BMD</code> for mainnet nodes is 15 milestones, 
which means that messages of which their <code>OMRSI</code> in relation to the <code>LSMI</code> is more than 15, are &quot;below max depth&quot;.</li>
</ul>
<h3 id="omrsi--ymrsi-example"><a class="header" href="#omrsi--ymrsi-example">OMRSI / YMRSI example</a></h3>
<p>Given the blue PoV message, the <code>OMRSI</code> of it is milestone 1 and <code>YMRSI</code> milestone 2.
Note that, here again, the milestones are also <code>Confirmed Root Messages</code>.
<img src="0008-uniform-random-tip-selection/images/otrsi_ytrsi.PNG" alt="sdf" /></p>
<h3 id="milestone-based-tip-scoring"><a class="header" href="#milestone-based-tip-scoring">Milestone based tip scoring</a></h3>
<p>The milestone based scoring defines a tip's score by investigating the tip's relation to
the cone it approves and previous issued  milestones.</p>
<p>A tip can have one of 3 score states:</p>
<ul>
<li><code>0</code>: The tip is lazy and should not be selected.</li>
<li><code>1</code>: The tip is somewhat lazy.</li>
<li><code>2</code>: The tip is a non-lazy tip.</li>
</ul>
<p>Definitions:</p>
<ul>
<li><code>C1</code>: Max allowed delta value for the <code>YMRSI</code> of a given message in relation to the current <code>LSMI</code>.</li>
<li><code>C2</code>: Max allowed delta value between <code>OMRSI</code> of a given message in relation to the current <code>LSMI</code>. </li>
<li><code>M</code>: Max allowed delta value between <code>OMRSI</code> of the given message in relation to the current <code>LSMI</code>.
<code>M</code> is the <code>below max depth (BMD)</code> parameter.</li>
</ul>
<p>Recommended defaults:</p>
<ul>
<li><code>C1</code> = 8 milestones</li>
<li><code>C2</code> = 13 milestones</li>
<li><code>M</code> = 15 milestones</li>
</ul>
<p>Scoring Algorithm (pseudo code):</p>
<pre><code>
enum Score (
    LAZY = 0
    SEMI_LAZY = 1
    NON_LAZY = 2
)

const (
    C1 = 8
    C2 = 13
    M = 15
)

func score(tip Tip) Score {
    
    // if the LSMI to YMRSI delta is over C1, then the tip is lazy
    if (LSMI - YMRSI(tip) &gt; C1) {
        return Score.LAZY
    }
    
    // if the OMRSI to LSMI delta is over M/below-max-depth, then the tip is lazy
    if (LSMI - OMRSI(tip) &gt; M) {
        return Score.LAZY
    }
    
    if (LSMI - OMRSI(tip) &gt; C2) {
        return Score.SEMI_LAZY
    }

    return Score.NON_LAZY
}
</code></pre>
<h3 id="random-tip-selection"><a class="header" href="#random-tip-selection">Random Tip-Selection</a></h3>
<p>A node should keep a set of non-lazy tips (score 2).
Every time a node is asked to select tips to be approved, it will pick randomly from the set. 
A node must not execute tip-selection if it is not synchronized.</p>
<p>A tip should not be removed from the tips set immediately after it was selected in <code>select()</code>,  to make it possible for it to be re-selected, which in turn makes the Tangle wider
and improves synchronization speed. A tip is removed from the tips set if <code>X</code> amount of direct
approvers are reached or if a certain amount of time <code>T</code> passed. 
It is recommended to use <code>X</code> = 2 and <code>T</code> = 3  but the threshold should be configurable.</p>
<h3 id="purpose-of-semi-lazy-tips"><a class="header" href="#purpose-of-semi-lazy-tips">Purpose Of Semi-Lazy Tips</a></h3>
<p>Semi-Lazy tips are not eligible for tip-selection, but the coordinator node may implement a tip selection algorithm
that confirms semi-lazy tips. Semi-lazy tips will usually be left behind, but parties interested in having them confirmed
are incentivized to run spammers that will actively reduce the amount of semi-lazy tips eligible for coordinator's tip selection. 
Given a coordinator that chooses semi-lazy tips, running such spammers may get those messages confirmed before
they become lazy.</p>
<h1 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h1>
<p>Depending on when and how often <code>YMRSI</code>/<code>OMRSI</code> values are computed, this tip-selection could still
have a slow runtime, as one would need to constantly walk down the Tangle to compute those
values. However, smart caching might resolve this issue. </p>
<h1 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h1>
<p>The previous tip-selection was written in accordance to the original IOTA whitepaper, as it also
functioned as part of the consensus mechanism.
However, relatively soon it became apparent that the cumulative weight computation was too heavy
for an actual high throughput scenario and, as such, the CW calculation is currently not used within
node implementations at all.</p>
<p>Because confirmations with the <a href="https://github.com/iotaledger/protocol-rfcs/blob/master/text/0005-white-flag/0005-white-flag.md">white-flag</a> approach no longer approve cones only with state mutations,
which are consistent with a previous ledger state, it makes sense to alter the tip-selection to provide 
a fast way to get tips to approve with one's own message.
The only important thing is to disincentive lazy behaviour to be able to maximize confirmation rate.</p>
<h1 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h1>
<h4 id="when-to-compute-the-score-and-ymrsiomrsi-of-a-transaction"><a class="header" href="#when-to-compute-the-score-and-ymrsiomrsi-of-a-transaction">When to compute the score and <code>YMRSI</code>/<code>OMRSI</code> of a transaction?</a></h4>
<p>It is not yet clear when or how often the <code>YMRSI</code>/<code>OMRSI</code> values of a transaction should be updated.
If the values are only computed once after a transaction became solid, the <code>YMRSI</code>/<code>OMRSI</code> might not
resemble the true values, as subsequent milestones might confirm transactions within the same cone the
given transaction approved.</p>
<p>Currently, we suggest recomputing the values every time a new milestone solidifies. 
Since different tips indirectly reference the same transactions, this computation can be optimized.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>milestone-merkle-validation</code></li>
<li>Start date: 2020-05-04</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/12">iotaledger/protocol-rfcs#0012</a>, <a href="https://github.com/iotaledger/protocol-rfcs/pull/31">iotaledger/protocol-rfcs#0031</a></li>
</ul>
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>In the IOTA protocol, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This RFC adds extra information to each milestone in the form of a Merkle tree hash, which allows nodes to explicitly validate their local view of the ledger state against the Coordinator's. This mechanism further enables a simple cryptographic proof of inclusion for transactions confirmed by the particular milestone.</p>
<h1 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h1>
<p>With the changes proposed in the IOTA protocol <a href="https://iotaledger.github.io/protocol-rfcs/0005-white-flag/0005-white-flag.html">RFC-0005</a>, milestones are allowed to reference conflicting transactions. These conflicts are then resolved by traversing the newly confirmed transactions in a global, deterministic order and applying the corresponding ledger state changes in that order. Conflicts or invalid transactions are ignored, but stay in the Tangle.
This approach has considerable advantages in terms of network security (e.g. protection against <a href="https://iota.cafe/t/conflict-spamming-attack/232">conflict spamming attacks</a>) and network performance. However, a milestone no longer represents the inclusion state of all its referenced transactions, but only marks the order in which transactions are checked against the ledger state and then, if not violating, applied. This has two significant drawbacks:</p>
<ul>
<li>Milestone validation: In the IOTA protocol, each node always compares the milestones issued by the Coordinator against its current ledger state. Discrepancies are reported and force an immediate halt of the node software. However, in the white flag proposal this detection is no longer possible as any milestone can lead to a valid ledger state by ignoring the corresponding violating ledger changes.</li>
<li>Proof of inclusion: In the pre-white-flag protocol, the inclusion of transaction t in the Tangle, and thus, the ledger, can be shown by providing an audit path of referencing transactions from t to its confirming milestone. In the white flag proposal this is no longer possible, as such an audit path does not provide any information on whether the transaction has been included or ignored.</li>
</ul>
<p>Note that the white flag proposal only changes the behavior of conflicting transactions. Messages without a transaction payload can never conflict and are thus always included in Tangle when they are first referenced by a milestone. As such, these messages do not need to be considered by the RFC and their processing and inclusion proof remain unchanged.</p>
<p>Where previously the structure of the Tangle alone was sufficient to address those issues, this RFC proposes to add the Merkle tree hash of all the valid (i.e. not ignored) newly confirmed transactions to the signed part of a milestone. This way, each IOTA node can check that the hash matches its local ledger state changes or provide a Merkle audit path for that milestone to prove the inclusion of a particular transaction.</p>
<h1 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed design</a></h1>
<h2 id="creating-a-milestone"><a class="header" href="#creating-a-milestone">Creating a Milestone</a></h2>
<ul>
<li>Perform tip selection to choose the parents referenced by the milestone.</li>
<li>Determine the topological order according to <a href="https://iotaledger.github.io/protocol-rfcs/0005-white-flag/0005-white-flag.html">RFC-0005</a> of the referenced messages that are not yet confirmed by a previous milestone.</li>
<li>Construct the list D consisting of the message IDs of all the not-ignored state-mutating transaction payloads in that particular order. A UTXO transaction is considered state-mutating, if it creates a new output.</li>
<li>Compute the 32-byte Merkle tree hash H = MTH(D).</li>
<li>Prepare the milestone payload as described in <a href="https://iotaledger.github.io/protocol-rfcs/0019-milestone-payload/0019-milestone-payload.md">RFC-0019</a>, where the field <code>Inclusion Merkle Root</code> is set to H.</li>
</ul>
<h2 id="milestone-validation"><a class="header" href="#milestone-validation">Milestone validation</a></h2>
<ul>
<li>Verify the signature of the milestone m.</li>
<li>Construct the ordered list D of the message IDs  of all the not-ignored state-mutating transaction payloads m confirms.</li>
<li>Compute H = MTH(D).</li>
<li>Verify that the field <code>Inclusion Merkle Root</code> in m matches H.</li>
</ul>
<h2 id="proof-of-inclusion"><a class="header" href="#proof-of-inclusion">Proof of inclusion</a></h2>
<ul>
<li>Identify the confirming milestone m of the input transaction t.</li>
<li>Determine the ordered list of the not-ignored messages m confirms.</li>
<li>Compute the Merkle audit path of t with respect to the Merkle tree for this ordered list.</li>
<li>Provide the audit path as well as m as proof of inclusion for t.</li>
</ul>
<h2 id="cryptographic-components"><a class="header" href="#cryptographic-components">Cryptographic components</a></h2>
<h3 id="merkle-hash-trees"><a class="header" href="#merkle-hash-trees">Merkle hash trees</a></h3>
<p>This RFC uses a binary Merkle hash tree for efficient auditing. In general, any cryptographic hashing algorithm can be used for this. However, we propose to use <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a>, as it provides a faster and more secure alternative to the widely used SHA-256. 
In the following we define the Merkle tree hash (MTH) function that returns the hash of the root node of a Merkle tree:</p>
<ul>
<li>The input is a list of binary data entries; these entries will be hashed to form the leaves of the tree.</li>
<li>The output is a single 32-byte hash.</li>
</ul>
<p>Given an ordered list of n input strings D<sub>n</sub> = {d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>n</sub>}, the Merkle tree hash of D is defined as follows:</p>
<ul>
<li>If D is an empty list, MTH(D) is the hash of an empty string:<br>
MTH({}) = BLAKE2().</li>
<li>If D has the length 1, the hash (also known as a leaf hash) is:<br>
MTH({d<sub>1</sub>}) = BLAKE2( 0x00 || d<sub>1</sub> ).</li>
<li>Otherwise, for D<sub>n</sub> with n &gt; 1:
<ul>
<li>Let k be the largest power of two less than n, i.e. k &lt; n ≤ 2k.</li>
<li>The Merkle tree hash can be defined recursively:<br>
MTH(D<sub>n</sub>) = BLAKE2( 0x01 || MTH({d<sub>1</sub>, ..., d<sub>k</sub>}) || MTH({d<sub>k+1</sub>, ..., d<sub>n</sub>}) ).</li>
</ul>
</li>
</ul>
<p>Note that the hash calculations for leaves and nodes differ. This is required to provide second preimage resistance: Without such a prefix, for a given input D an attacker could replace  two (or more) leaves with their corresponding aggregated node hash without changing the final value of MTH(D). This violates the fundamental assumption that, given MTH(D), it should be practically impossible to find a different input D' leading to the same value. Adding a simple prefix mitigates this issue, since now leaf and node hashes are computed differently and can no longer be interchanged.</p>
<p>Note that we do not require the length of the input to be a power of two. However, its shape is still uniquely determined by the number of leaves.</p>
<h3 id="merkle-audit-paths"><a class="header" href="#merkle-audit-paths">Merkle audit paths</a></h3>
<p>A Merkle audit path for a leaf in a Merkle hash tree is the shortest list of additional nodes in a Merkle tree required to compute the Merkle tree hash for that tree. At each step towards the root, a node from the audit path is combined with a node computed so far. If the root computed from the audit path matches the Merkle tree hash, then the audit path is proof that the leaf exists in the tree.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Merkle tree with 7 leaves:</p>
<ul>
<li>input D:
<ol>
<li>52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c649</li>
<li>81855ad8681d0d86d1e91e00167939cb6694d2c422acd208a0072939487f6999</li>
<li>eb9d18a44784045d87f3c67cf22746e995af5a25367951baa2ff6cd471c483f1</li>
<li>5fb90badb37c5821b6d95526a41a9504680b4e7c8b763a1b1d49d4955c848621</li>
<li>6325253fec738dd7a9e28bf921119c160f0702448615bbda08313f6a8eb668d2</li>
<li>0bf5059875921e668a5bdf2c7fc4844592d2572bcd0668d2d6c52f5054e2d083</li>
<li>6bf84c7174cb7476364cc3dbd968b0f7172ed85794bb358b0c3b525da1786f9f</li>
</ol>
</li>
<li>Merkle tree hash H = MTH(D) (32-byte): bf67ce7ba23e8c0951b5abaec4f5524360d2c26d971ff226d3359fa70cdb0beb</li>
</ul>
<pre><code>root: bf67ce7ba23e8c0951b5abaec4f5524360d2c26d971ff226d3359fa70cdb0beb
 ├─ node: 03bcbb3cf4314eab2f5ae68c767ff0a5fec4573c865728231f71d596fd867b56
 │  ├─ node: ae4505f4cfae93586e23958ca88d35d2f34d43def49786b6d0d4224b819f4cda
 │  │  │  ┌ msg id: 52fdfc072182654f163f5f0f9a621d729566c74d10037c4d7bbb0407d1e2c649
 │  │  ├──┴ leaf: 3d1399c64ff0ae6a074afa4cd2ce4eab8d5c499c1da6afdd1d84b7447cc00544
 │  │  │  ┌ msg id: 81855ad8681d0d86d1e91e00167939cb6694d2c422acd208a0072939487f6999
 │  │  └──┴ leaf: 83b0b255014e9a3656f0004a3f17943a20b715ef9c3e7cb85a6b2abac15e00d0
 │  └─ node: 54d51291aca22ce5b04cd3e6584fa3026ebe86ef86f0a6dfb47ab843801d4b38
 │     │  ┌ msg id: eb9d18a44784045d87f3c67cf22746e995af5a25367951baa2ff6cd471c483f1
 │     ├──┴ leaf: ad4bc0a34b27f37810f2ff3a8177ecc98402f8f59a06270f9d285fdf764e45fe
 │     │  ┌ msg id: 5fb90badb37c5821b6d95526a41a9504680b4e7c8b763a1b1d49d4955c848621
 │     └──┴ leaf: ffb3a7c6bea8f9fdcfb26f4701ad6e912a6076e1a40663607dbe110ebfc9a571
 └─ node: ce22d5bc728023e7ab6a9eb8f58baf62b9565fc8baeef4b377daa6709dbe598c
    ├─ node: e14c8af1258005cd0dbed88f0c5885c6988f319bb8f24272a7495592b873c169
    │  │  ┌ msg id: 6325253fec738dd7a9e28bf921119c160f0702448615bbda08313f6a8eb668d2
    │  ├──┴ leaf: 1c062628a7a147cc6a4defa655ce6c4ae5b838b4b4cd81b12e8924b5b4b5cca6
    │  │  ┌ msg id: 0bf5059875921e668a5bdf2c7fc4844592d2572bcd0668d2d6c52f5054e2d083
    │  └──┴ leaf: 2ef4e2ad06b8c8ae1fd4b28b5ed166829533fbfff1f6c14218358537da277fa3
    │  ┌ msg id: 6bf84c7174cb7476364cc3dbd968b0f7172ed85794bb358b0c3b525da1786f9f
    └──┴ leaf: 7ec774ebc33ed4ca298e8a1cf1f569e36c6784467d63b055efd7612abe2858a4
</code></pre>
<h1 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h1>
<ul>
<li>The computation of the Merkle tree hash of D<sub>n</sub> requires 2n-1 evaluations of the underlying hashing algorithm. This makes the milestone creation and validation computationally slightly more expensive.</li>
</ul>
<h1 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h1>
<p>It is a crucial security feature of the IOTA network that nodes are able to validate the issued milestones. As a result, if the Coordinator were to ever send an invalid milestone, such as one that references counterfeit transactions, the rest of the nodes would not accept it. In a pure implementation of <a href="https://iotaledger.github.io/protocol-rfcs/0005-white-flag/0005-white-flag.html">RFC-0005</a> this feature is lost and must be provided by external mechanisms.
A Merkle tree hash provides an efficient, secure and well-established method to compress the information about the confirmed transactions in such a way, that they fit in the milestone transaction.</p>
<p>In this context, it could also be possible to use an unsecured checksum (such as CRCs) of the message IDs instead of a Merkle tree hash. However, the small benefit of faster computation times does no justify the potential security risks and attack vectors.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>binary-to-ternary-encoding</code></li>
<li>Start date: 2020-06-08</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/15">iotaledger/protocol-rfcs#0015</a></li>
</ul>
<h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<p>In the IOTA protocol, a transaction is represented as ternary data. However, sometimes it is necessary to store binary data (e.g. the digest of a binary hash function) inside of a transaction. This requires the conversion of binary into ternary strings.
The IOTA client libraries support the opposite conversion that encodes 5 trits as 1 byte (sometimes also referred to as <code>t5b1</code> encoding), which is used for network communication and in storage layers. This RFC describes the corresponding counterpart to encode 1 byte as 6 trits.</p>
<h1 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h1>
<p>A byte is composed of 8 bits that can represent 2<sup>8</sup> = 256 different values. On the other hand, 6 trits can hold 3<sup>6</sup> = 729 values while 5 trits can hold 3<sup>5</sup> = 243 values. Therefore, the most memory-efficient way to encode one byte requires the use of 6 trits. Although there exist many potential encoding schemes to convert binary data into ternary, the proposed version has been designed to directly match the widely used <code>t5b1</code> encoding.</p>
<p>It is important to note that the <code>b1t6</code> encoding presented in this RFC does not replace the current <code>t5b1</code> encoding (or its corresponding decoding): <code>t5b1</code> is for example used to store trytes in a binary database, while <code>b1t6</code> will be used to attach binary data to an IOTA transaction.</p>
<h1 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed design</a></h1>
<h3 id="bytes-to-trits"><a class="header" href="#bytes-to-trits">Bytes to trits</a></h3>
<p>In order to encode a binary string S into ternary, each byte of S is interpreted as a signed (two's complement) 8-bit integer value v. Then, v is encoded as a little-endian 6-trit string in balanced ternary representation. Finally, the resulting groups of trits are concatenated.</p>
<p>This algorithm can also be described using the following pseudocode:</p>
<pre><code>T ← []
foreach byte b in S:
  v ← int8(b)
  g ← IntToTrits(v, 6)
  T ← T || g
</code></pre>
<p>Here, the function <code>IntToTrits</code> converts a signed integer value into its corresponding balanced ternary representation in little-endian order of the given length. The functionality of <code>IntToTrits</code> exactly matches the one used to e.g. encode the transaction values as trits in the current IOTA protocol.</p>
<h3 id="trits-to-bytes"><a class="header" href="#trits-to-bytes">Trits to bytes</a></h3>
<p>Given a trit string T as the result of the previous encoding, T is converted back to its original byte string S by simply reversing the conversion:</p>
<pre><code>S ← []
foreach 6-trit group g in T:
  v ← TritsToInt(g)
  b ← byte(v)
  S ← S || b
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li>I
<ul>
<li>binary (hex): <code>00</code></li>
<li>ternary (trytes): <code>99</code></li>
</ul>
</li>
<li>II
<ul>
<li>binary (hex): <code>0001027e7f8081fdfeff</code></li>
<li>ternary (trytes):
<code>99A9B9RESEGVHVX9Y9Z9</code></li>
</ul>
</li>
<li>III
<ul>
<li>binary (hex): <code>9ba06c78552776a596dfe360cc2b5bf644c0f9d343a10e2e71debecd30730d03</code></li>
<li>ternary (trytes): <code>GWLW9DLDDCLAJDQXBWUZYZODBYPBJCQ9NCQYT9IYMBMWNASBEDTZOYCYUBGDM9C9</code></li>
</ul>
</li>
</ul>
<h1 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h1>
<ul>
<li>Conceptually, one byte can be encoded using log<sub>3</sub>(256) ≈ 5.0474 trits. Thus, encoding 1 byte as 6 trits consumes considerably more memory than the mathematical minimum.</li>
<li>Depending on the actual implementation the conversion might be malleable: E.g. since <code>byte(-1) = 0xff</code> and <code>byte(255) = 0xff</code>, both <code>Z9</code> (-1) and <code>LI</code>(255) could be decoded as <code>ff</code>. However, <code>LI</code> can never be the result of a valid <code>b1t6</code> encoding. As such, the implementation must reject such invalid inputs.</li>
</ul>
<h1 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h1>
<p>There are several ways to convert binary data into ternary, e.g.</p>
<ul>
<li>the conversion used as part of the <a href="https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md">Kerl</a> hash function encoding chunks of 48 bytes as 242 trits,</li>
<li>or by encoding each bit as one trit with the corresponding value.</li>
</ul>
<p>The current client libraries do not provide any functionality to convert an arbitrary amount of bytes into trits. The closest available functionality is the ASCII to trit conversion, which is used for human-readable messages in transactions:</p>
<pre><code>T ← []
foreach char c in S:
  first ← uint8(c) mod 27
  second ← (uint8(c)-first) / 27
  T ← T || IntToTrits(first, 3) || IntToTrits(second, 3)
</code></pre>
<p>This function can be adapted to encode any general byte string. However, the conversion seems rather arbitrary and the algorithm is computationally more intense than the proposed solution.
On the other hand, using the algorithm from this RFC also for the conversion of ASCII messages would break backward compatibility, which is also undesirable.</p>
<p>Each conversion method has different advantages and disadvantages. However, since the <code>t5b1</code> encoding is well-defined and has been used in <a href="https://github.com/iotaledger/iri">IRI</a> for both network communications and storage layers for a long time, choosing the direct counterpart for the opposite conversion represents the most logical solution providing a nice balance between performance and memory-efficiency.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>tangle-message</code></li>
<li>Start date: 2020-07-28</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/0017">iotaledger/protocol-rfcs#0017</a></li>
<li>Recent updates:
<ul>
<li>(<a href="https://github.com/iotaledger/protocol-rfcs/pull/0037">iotaledger/protocol-rfcs#0037</a>) Fixed internal links</li>
</ul>
</li>
</ul>
<h1 id="summary-4"><a class="header" href="#summary-4">Summary</a></h1>
<p>The Tangle is the graph data structure behind IOTA. In the current IOTA protocol, the vertices of the Tangle are represented by transactions. This document proposes an abstraction of this idea where the vertices are generalized <em>messages</em>, which then contain the transactions or other structures that are processed by the IOTA protocol. Just as before, each message directly approves other messages, which are known as <em>parents</em>.</p>
<p>The messages can contain payloads. These are core payloads that will be processed by all nodes as part of the IOTA protocol. Some payloads may have other nested payloads embedded inside. Hence, parsing is done layer by layer.</p>
<h1 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h1>
<p>To better understand this layered design, consider the Internet Protocol (IP), for example: There is an Ethernet frame that contains an IP payload. This in turn contains a TCP packet that encapsulates an HTTP payload. Each layer has a certain responsibility and once this responsibility is completed, we move on to the next layer.</p>
<p>The same is true with how messages are parsed. The outer layer of the message enables the mapping of the message to a vertex in the Tangle and allow us to perform some basic validation. The next layer may be a transaction that mutates the ledger state, and one layer further may provide some extra functionality on the transactions to be used by applications.</p>
<p>By making it possible to add and exchange payloads, an architecture is being created that can easily be extended to accommodate future needs.</p>
<h1 id="detailed-design-4"><a class="header" href="#detailed-design-4">Detailed design</a></h1>
<h2 id="data-types"><a class="header" href="#data-types">Data types</a></h2>
<p>The following are data types that will be used when we specify fields in the message and payloads.</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>uint8</td><td>An unsigned 8-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint16</td><td>An unsigned 16-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint32</td><td>An unsigned 32-bit integer encoded in Little Endian.</td></tr>
<tr><td>uint64</td><td>An unsigned 64-bit integer encoded in Little Endian.</td></tr>
<tr><td>ByteArray[N]</td><td>A static size byte array of length N.</td></tr>
<tr><td>ByteArray</td><td>A dynamically sized byte array. A leading uint32 denotes its length in bytes.</td></tr>
</tbody></table>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<h3 id="message-id"><a class="header" href="#message-id">Message ID</a></h3>
<p>The <em>Message ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized message.</p>
<h3 id="serialized-layout"><a class="header" href="#serialized-layout">Serialized Layout</a></h3>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Network ID</td>
    <td>uint64</td>
    <td>Network identifier. This field denotes whether the message was meant for mainnet, testnet, or a private net. It also marks what protocol rules apply to the message. Usually, it will be set to the first 8 bytes of the BLAKE2b-256 hash of the concatenation of the network type and the protocol version string.</td>
  </tr>
  <tr>
    <td>Parents Count</td>
    <td>uint8</td>
    <td>The number of messages that are directly approved.</td>
  </tr>
  <tr>
    <td valign="top">Parents <code>anyOf</code></td>
    <td colspan="2">
      <details>
        <summary>Parent</summary>
        <blockquote>
          References another directly approved message.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Message ID</td>
            <td>ByteArray[32]</td>
            <td>The Message ID of the parent.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Payload Length</td>
    <td>uint32</td>
    <td>The length of the following payload in bytes. A length of 0 means no payload will be attached.</td>
  </tr>
  <tr>
    <td valign="top">Payload <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Generic Payload</summary>
        <blockquote>
          An outline of a generic payload
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Payload Type</td>
            <td>uint32</td>
            <td>
              The type of the payload. It will instruct the node how to parse the fields that follow.
            </td>
          </tr>
          <tr>
            <td>Data Fields</td>
            <td>ANY</td>
            <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
          </tr>
        </table>
      </details>
  <tr>
    <td>Nonce</td>
    <td>uint64</td>
    <td>The nonce which lets this message fulfill the PoW requirement.</td>
  </tr>
</table>
<h2 id="message-validation"><a class="header" href="#message-validation">Message validation</a></h2>
<p>The following criteria defines whether the message passes the syntactical validation:</p>
<ul>
<li>The total message size must not exceed 32 KiB (32 * 1024 bytes).</li>
<li>Parents:
<ul>
<li><code>Parents Count</code> must be at least 1 and not larger than 8.</li>
<li><code>Parents</code> must be sorted in lexicographical order.</li>
<li>Each <code>Message ID</code> must be unique.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="0017-tangle-message/0017-tangle-message.html#payloads">Payloads</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li><code>Nonce</code> must be a valid solution of the message PoW as described in <a href="https://iotaledger.github.io/protocol-rfcs/0024-message-pow/0024-message-pow.html">RFC-0024</a>.</li>
<li>There must be no trailing bytes after all message fields have been parsed.</li>
</ul>
<h2 id="payloads"><a class="header" href="#payloads">Payloads</a></h2>
<p>While messages without a payload, i.e. <code>Payload Length</code> set to zero, are valid, such messages do not contain any information. As such, messages usually contain a payload. The detailed specification of each payload type is out of scope of this RFC. The following table lists all currently specified payloads that can be part of a message and links to their specification. The <em>indexation payload</em> will be specified here as an example:</p>
<table><thead><tr><th>Payload Name</th><th>Type Value</th><th>RFC</th></tr></thead><tbody>
<tr><td>Transaction</td><td>0</td><td><a href="https://iotaledger.github.io/protocol-rfcs/0018-transaction-payload/0018-transaction-payload.html">RFC-0018</a></td></tr>
<tr><td>Milestone</td><td>1</td><td><a href="https://iotaledger.github.io/protocol-rfcs/0019-milestone-payload/0019-milestone-payload.html">RFC-0019</a></td></tr>
<tr><td>Indexation</td><td>2</td><td><a href="0017-tangle-message/0017-tangle-message.html#indexation-payload">RFC-0017</a></td></tr>
</tbody></table>
<h3 id="indexation-payload"><a class="header" href="#indexation-payload">Indexation payload</a></h3>
<p>This payload allows the addition of an index to the encapsulating message, as well as some arbitrary data. Nodes will expose an API that allows to query messages by index.</p>
<p>The structure of the indexation payload is as follows:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Payload Type</td><td>uint32</td><td>Set to <b>value 2</b> to denote an <i>Indexation Payload</i>.</td></tr>
<tr><td>Index Length</td><td>uint16</td><td>The length of the following index field in bytes.</td></tr>
<tr><td>Index</td><td>ByteArray[Index Length]</td><td>The index key of the message</td></tr>
<tr><td>Data</td><td>ByteArray</td><td>Binary data.</td></tr>
</tbody></table>
<p>Note that <code>Index</code> field must be at least 1 byte and not longer than 64 bytes for the payload to be valid. The <code>Data</code> may have a length of 0.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Below is the full serialization of a valid message with an indexation payload. The index is the &quot;IOTA&quot; ASCII string and the data is the &quot;hello world&quot; ASCII string. Bytes are expressed as hexadecimal numbers.</p>
<ul>
<li>Network ID (8-byte): <code>0000000000000000</code> (0)</li>
<li>Parents Count (1-byte): <code>02</code> (2)</li>
<li>Parents (64-byte):
<ul>
<li><code>210fc7bb818639ac48a4c6afa2f1581a8b9525e20fda68927f2b2ff836f73578</code></li>
<li><code>db0fa54c29f7fd928d92ca43f193dee47f591549f597a811c8fa67ab031ebd9c</code></li>
</ul>
</li>
<li>Payload Length (4-byte): <code>19000000</code> (25)</li>
<li>Payload (25-byte):
<ul>
<li>Payload Type (4-byte): <code>02000000</code> (2)</li>
<li>Index Length (2-byte): <code>0400</code> (4)</li>
<li>Index (4-byte): <code>494f5441</code> (&quot;IOTA&quot;)</li>
<li>Data (15-byte):
<ul>
<li>Length (4-byte): <code>0b000000</code> (11)</li>
<li>Data (11-byte): <code>68656c6c6f20776f726c64</code> (&quot;hello world&quot;)</li>
</ul>
</li>
</ul>
</li>
<li>Nonce (8-byte): <code>ce6d000000000000</code> (28110)</li>
</ul>
<h1 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h1>
<p>Instead of creating a layered approach, we could have simply created a flat transaction message that is tailored to mutate the ledger state, and try to fit all the use cases there. For example, with the indexed data use case, we could have filled some section of the transaction with that particular data. Then, this transaction would not correspond to a ledger mutation but instead only carry data.</p>
<p>This approach seems less extensible. It might have made sense if we had wanted to build a protocol that is just for ledger mutating transactions, but we want to be able to extend the protocol to do more than that.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>transaction-payload</code></li>
<li>Start date: 2020-07-10</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/18">iotaledger/protocol-rfcs#18</a></li>
</ul>
<h1 id="summary-5"><a class="header" href="#summary-5">Summary</a></h1>
<p>In the current IOTA protocol, transactions are grouped into so-called bundles to assure that they can only be confirmed as one unit. This RFC proposes a new UTXO-based transaction structure containing all the inputs and outputs of a transfer. Specifically, this RFC defines a transaction payload for the <em>messages</em> described in the IOTA protocol <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html">RFC-0017</a>.</p>
<h1 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h1>
<p>Currently, the vertices of the Tangle are represented by transactions, where each transaction defines either an input or output. A grouping of those input/output transaction vertices makes up a bundle which transfers the given values as an atomic unit (the entire bundle is applied or none of it). An applied bundle consumes the input transactions' funds and creates the corresponding deposits into the output transactions' target addresses. Furthermore, additional meta transactions can be part of the bundle to carry parts of the signature which do not fit into a single input transaction.</p>
<p>The bundle concept has proven to be very challenging in practice because of the following issues:</p>
<ul>
<li>Since the data making up the bundle is split across multiple vertices, it complicates the validation of the entire transfer. Instead of being able to immediately tell whether a bundle is valid or not, a node implementation must first collect all parts of the bundle before any actual validation can happen. This increases the complexity of the node implementation.</li>
<li>Reattaching the tail transaction of a bundle causes the entire transfer to be reapplied.</li>
<li>Due to the split across multiple transaction vertices and having to do PoW for each of them, a bundle might already be lazy in terms of where it attaches, reducing its chances to be confirmed.</li>
</ul>
<p>To fix the problems mentioned above and to create a more flexible transaction structure, the goal is to achieve a self-contained transaction structure defining the data of the entire transfer as a payload to be embedded into a message.</p>
<p>The new transaction structure should fulfil the following criteria:</p>
<ul>
<li>Support for Ed25519 (and thus reusable addresses).</li>
<li>Support for adding new types of signature schemes, addresses, inputs, and outputs as part of protocol upgrades.</li>
<li>Self-contained, as in being able to validate the transaction immediately after receiving it.</li>
<li>Enable unspent transaction outputs (UTXO) as inputs instead of an account based model.</li>
</ul>
<h1 id="detailed-design-5"><a class="header" href="#detailed-design-5">Detailed design</a></h1>
<h2 id="utxo"><a class="header" href="#utxo">UTXO</a></h2>
<p>The <em>unspent transaction output</em> (UTXO) model defines a ledger state where balances are not directly associated to addresses but to the outputs of transactions. In this model, transactions reference outputs of previous transactions as inputs, which are consumed (removed) to create new outputs. A transaction must consume all the funds of the referenced inputs.</p>
<p>Using a UTXO based model provides several benefits:</p>
<ul>
<li>Parallel validation of transactions.</li>
<li>Easier double-spend detection, since conflicting transactions would reference the same UTXO.</li>
<li>Replay-protection which is important when having reusable addresses. Replaying the same transaction would manifest itself as already being applied or existent and thus not have any impact.</li>
<li>Technically seen, balances are no longer associated to addresses which raises the level of abstraction and thus enables other types of outputs with particular unlock criteria.</li>
</ul>
<p>Within a transaction using UTXOs, inputs and outputs make up the to-be-signed data of the transaction. The section unlocking the inputs is called the <em>unlock block</em>. An unlock block may contain a signature proving ownership of a given input's address and/or other unlock criteria.</p>
<p>The following image depicts the flow of funds using UTXO:</p>
<p><img src="0018-transaction-payload/img/utxo.png" alt="UTXO flow" /></p>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<h3 id="serialized-layout-1"><a class="header" href="#serialized-layout-1">Serialized layout</a></h3>
<p>A <em>Transaction Payload</em> is made up of two parts:</p>
<ol>
<li>The <em>Transaction Essence</em> part which contains the inputs, outputs and an optional embedded payload.</li>
<li>The <em>Unlock Blocks</em> which unlock the inputs of the <em>Transaction Essence</em>. When an unlock block contains a signature, it signs the entire <em>Transaction Essence</em> part.</li>
</ol>
<p>All values are serialized in little-endian encoding. The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same serialized byte sequence.</p>
<p>The <em>Transaction ID</em> is the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the entire serialized payload data including signatures.</p>
<p>The following table structure describes the entirety of a <em>Transaction Payload</em> in its serialized form:</p>
<ul>
<li>Data Type Notation, see <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html#data-types">RFC-0017</a></li>
<li><details>
  <summary>Subschema Notation</summary>
  <table>
      <tr>
          <th>Name</th>
          <th>Description</th>
      </tr>
      <tr>
          <td><code>oneOf</code></td>
          <td>One of the listed subschemas.</td>
      </tr>
      <tr>
          <td><code>optOneOf</code></td>
          <td>Optionally one of the listed subschemas.</td>
      </tr>
      <tr>
          <td><code>anyOf</code></td>
          <td>Any (one or more) of the listed subschemas.</td>
      </tr>
  </table>
</li>
</ul>
</details>
<p></p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>
      Set to <strong>value 0</strong> to denote a <i>Transaction Payload</i>.
    </td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Transaction Essence</summary>
        <blockquote>
          Describes the essence data making up a transaction by defining its inputs, outputs and an optional payload.
        </blockquote>
        <table>
          <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
          </tr>
          <tr>
            <td>Transaction Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote a <i>Transaction Essence</i>.
            </td>
          </tr>
          <tr>
            <td>Inputs Count</td>
            <td>uint16</td>
            <td>The number of input entries.</td>
          </tr>
          <tr>
            <td valign="top">Inputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>UTXO Input</summary>
                <blockquote>
                  Describes an input which references an unspent transaction output to consume.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Input Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>UTXO Input</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Transaction ID</td>
                    <td>ByteArray[32]</td>
                    <td>The BLAKE2b-256 hash of the transaction payload containing the referenced output.</td>
                  </tr>
                  <tr>
                    <td>Transaction Output Index</td>
                    <td>uint16</td>
                    <td>The output index of the referenced output.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Outputs Count</td>
            <td>uint16</td>
            <td>The number of output entries.</td>
          </tr>
          <tr>
            <td valign="top">Outputs <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>SigLockedSingleOutput</summary>
                <blockquote>
                  Describes a deposit to a single address which is unlocked via a signature.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Output Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote a <i>SigLockedSingleOutput</i>.
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                      <details>
                        <summary>Ed25519 Address</summary>
                        <table>
                          <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                          </tr>
                          <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                          </tr>
                          <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
                          </tr>
                        </table>
                      </details>
                    </td>
                  </tr>
                  <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of tokens to deposit.</td>
                  </tr>
                </table>
              </details>
              <details>
                <summary>SigLockedDustAllowanceOutput</summary>
                <blockquote>
                  Describes a deposit which as a special property also alters the dust allowance of the target address.
                </blockquote>
                <table>
                  <tr>
                    <td><b>Name</b></td>
                    <td><b>Type</b></td>
                    <td><b>Description</b></td>
                  </tr>
                  <tr>
                    <td>Output Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 1</strong> to denote a <i>SigLockedDustAllowanceOutput</i>.
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">Address <code>oneOf</code></td>
                    <td colspan="2">
                      <details>
                        <summary>Ed25519 Address</summary>
                        <table>
                          <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                          </tr>
                          <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                              Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                          </tr>
                          <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is the BLAKE2b-256 hash of the public key.</td>
                          </tr>
                        </table>
                      </details>
                    </td>
                  </tr>
                  <tr>
                    <td>Amount</td>
                    <td>uint64</td>
                    <td>The amount of tokens to deposit.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Generic Payload</summary>
                <blockquote>
                  An outline of a generic payload.
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Payload Type</td>
                    <td>uint32</td>
                    <td>
                      The type of the payload. It will instruct the node how to parse the fields that follow.
                    </td>
                  </tr>
                  <tr>
                    <td>Data Fields</td>
                    <td>ANY</td>
                    <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                  </tr>
                </table>
              </details>
          <tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Unlock Blocks Count</td>
    <td>uint16</td>
     <td>The number of unlock block entries. It must match the field <code>Inputs Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Unlock Blocks <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Signature Unlock Block</summary>
        <blockquote>
          Defines an unlock block containing a signature.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 0</strong> to denote a <i>Signature Unlock Block</i>.
            </td>
          </tr>
          <tr>
            <td valign="top">Signature <code>oneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Signature</summary>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Signature Type</td>
                    <td>uint8</td>
                    <td>
                      Set to <strong>value 0</strong> to denote an <i>Ed25519 Signature</i>.
                    </td>
                  </tr>
                  <tr>
                    <td>Public key</td>
                    <td>ByteArray[32]</td>
                    <td>The Ed25519 public key of the signature.</td>
                  </tr>
                  <tr>
                    <td>Signature</td>
                    <td>ByteArray[64]</td>
                    <td>The Ed25519 signature signing the Blake2b-256 hash of the serialized <i>Transaction Essence</i>.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
        </table>
      </details>
      <details open="true">
        <summary>Reference Unlock Block</summary>
        <blockquote>
          References a previous unlock block, where the same unlock block can be used for multiple inputs.
        </blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
              Set to <strong>value 1</strong> to denote a <i>Reference Unlock Block</i>.
            </td>
          </tr>
          <tr>
            <td>Reference</td>
            <td>uint16</td>
            <td>Represents the index of a previous unlock block.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h3 id="transaction-parts"><a class="header" href="#transaction-parts">Transaction parts</a></h3>
<p>In general, all parts of a <i>Transaction Payload</i> begin with a byte describing the type of the given part. This improves the flexibility to introduce new types/versions of the given part in the future.</p>
<h4 id="transaction-essence-data"><a class="header" href="#transaction-essence-data">Transaction Essence data</a></h4>
<p>The <i>Transaction Essence</i> of a <i>Transaction Payload</i> carries the inputs, outputs, and an optional payload. The <i>Transaction Essence</i> is an explicit type and therefore starts with its own <i>Transaction Essence Type</i> byte which is of value 0.</p>
<h5 id="inputs"><a class="header" href="#inputs">Inputs</a></h5>
<p>The <i>Inputs</i> part holds the inputs to consume in order to fund the outputs of the <i>Transaction Payload</i>. Currently, there is only one type of input, the <i>UTXO Input</i>. In the future, more types of inputs may be specified as part of protocol upgrades.</p>
<p>Each input must be accompanied by a corresponding <i>Unlock Block</i> at the same index in the <i>Unlock Blocks</i> part of the <i>Transaction Payload</i>.</p>
<h6 id="utxo-input"><a class="header" href="#utxo-input">UTXO Input</a></h6>
<p>A <i>UTXO Input</i> is an input which references an unspent output of a previous transaction. This UTXO is uniquely defined by the <em>Transaction ID</em> of that transaction together with corresponding output index. Each <i>UTXO Input</i> must be accompanied by an <i>Unlock Block</i> that is allowed to unlock the output the <i>UTXO Input</i> is referencing.</p>
<p>Example:
If the input references an output to an Ed25519 address, then the corresponding unlock block must be of type <i>Signature Unlock Block</i> holding an Ed25519 signature.</p>
<h5 id="outputs"><a class="header" href="#outputs">Outputs</a></h5>
<p>The <i>Outputs</i> part holds the outputs that are created by this <i>Transaction Payload</i>. The following output types are supported:</p>
<h6 id="siglockedsingleoutput"><a class="header" href="#siglockedsingleoutput">SigLockedSingleOutput</a></h6>
<p>The <i>SigLockedSingleOutput</i> defines an output (with a certain amount) to a single target address which is unlocked via a signature proving ownership over the given address. This output supports addresses of different types.</p>
<h6 id="siglockeddustallowanceoutput"><a class="header" href="#siglockeddustallowanceoutput">SigLockedDustAllowanceOutput</a></h6>
<p>The <i>SigLockedDustAllowanceOutput</i> works in the same way as a <i>SigLockedSingleOutput</i> but additionally controls the dust allowance on the target address. See <a href="https://github.com/iotaledger/protocol-rfcs/pull/32">Dust Protection RFC-0032 (draft)</a> for further information.</p>
<h5 id="payload"><a class="header" href="#payload">Payload</a></h5>
<p>The  <em>Transaction Essence</em> itself can contain another payload as described in general in <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html">RFC-0017</a>. The <a href="0018-transaction-payload/0018-transaction-payload.html#semantic-validation">semantic validity</a> of the encapsulating <em>Transaction Payload</em> does not have any impact on the payload.</p>
<p>The following table lists all the payload types that can be nested inside a <em>Transaction Essence</em> as well as links to the corresponding specification:</p>
<table><thead><tr><th>Name</th><th>Type Value</th><th>RFC</th></tr></thead><tbody>
<tr><td>Indexation</td><td>2</td><td><a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html#indexation-payload">RFC-0017</a></td></tr>
</tbody></table>
<h4 id="unlock-blocks"><a class="header" href="#unlock-blocks">Unlock Blocks</a></h4>
<p>The <i>Unlock Blocks</i> part holds the unlock blocks unlocking inputs within a <i>Transaction Essence</i>. The following types of unlock blocks are supported:</p>
<h5 id="signature-unlock-block"><a class="header" href="#signature-unlock-block">Signature Unlock Block</a></h5>
<p>A <i>Signature Unlock Block</i> defines an <i>Unlock Block</i> which holds a signature signing the BLAKE2b-256 hash of the <i>Transaction Essence</i> (including the optional payload).</p>
<h5 id="reference-unlock-block"><a class="header" href="#reference-unlock-block">Reference Unlock block</a></h5>
<p>A <i>Reference Unlock Block</i> defines an <i>Unlock Block</i> which references a previous <i>Unlock Block</i> (which must not be another <i>Reference Unlock Block</i>). It <strong>must</strong> be used if multiple inputs can be unlocked via the same <i>Unlock Block</i>.</p>
<p>Example:
Consider a <i>Transaction Essence</i> containing the <i>UTXO Inputs</i> 0, 1 and 2, where 0 and 2 are both spending outputs belonging to the same Ed25519 address A and 1 is spending from a different address B. This results in the following structure of the <i>Unlock Blocks</i> part:</p>
<table><thead><tr><th>Index</th><th>Unlock Block</th></tr></thead><tbody>
<tr><td>0</td><td>A <em>Signature Unlock Block</em> holding the Ed25519 signature for address A.</td></tr>
<tr><td>1</td><td>A <em>Signature Unlock Block</em> holding the Ed25519 signature for address B.</td></tr>
<tr><td>2</td><td>A <em>Reference Unlock Block</em> which references 0, as both require the same signature for A.</td></tr>
</tbody></table>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>A <i>Transaction Payload</i> has different validation stages, since some validation steps can only be executed when certain information has (or has not) been received. We therefore distinguish between syntactic and semantic validation:</p>
<h3 id="syntactic-validation"><a class="header" href="#syntactic-validation">Syntactic validation</a></h3>
<p>Syntactic validation is checked as soon as the transaction data has been received in its entirety. It validates the structure but not the signatures of the transaction. If the transaction does not pass this stage, it must not be broadcasted further and can be discarded right away.</p>
<p>The following criteria defines whether a payload passes the syntactical validation:</p>
<ul>
<li>Essence:
<ul>
<li><code>Transaction Type</code> value must denote a <em>Transaction Essence</em>.</li>
<li>Inputs:
<ul>
<li><code>Inputs Count</code> must be 0 &lt; x ≤ 127.</li>
<li>For each input the following must be true:
<ul>
<li><code>Input Type</code> must denote a <em>UTXO Input</em>.</li>
<li><code>Transaction Output Index</code> must be 0 ≤ x &lt; 127.</li>
</ul>
</li>
<li><code>Inputs</code> must be sorted in lexicographical order of their serialized form.<sup>1</sup></li>
<li>Each pair of <code>Transaction ID</code> and <code>Transaction Output Index</code> must be unique in the inputs set.</li>
</ul>
</li>
<li>Outputs:
<ul>
<li><code>Outputs Count</code> must be 0 &lt; x ≤ 127.</li>
<li>For each input the following must be true:
<ul>
<li><code>Output Type</code> must denote a <em>SigLockedSingleOutput</em> or a <em>SigLockedDustAllowanceOutput</em>.</li>
<li><code>Address Type</code> must denote an <em>Ed25519 Address</em>.</li>
<li><code>Amount</code> must be larger than zero.</li>
</ul>
</li>
<li><code>Outputs</code> must be sorted in lexicographical order of their serialized form.<sup>1</sup></li>
<li>Each <code>Address</code> must be unique per output type. For example, a <em>SigLockedSingleOutput</em> and a <em>SigLockedDustAllowanceOutput</em> can have the same address, but not two <em>SigLockedSingleOutputs</em>.</li>
<li>The sum of all <code>Amount</code> fields must not exceed the total IOTA supply of 2,779,530,283,277,761.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="0018-transaction-payload/0018-transaction-payload.html#payload">Payload</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
</ul>
</li>
<li>Unlock Blocks:
<ul>
<li><code>Unlock Blocks Count</code> must match <code>Inputs Count</code> of the <em>Transaction Essence</em>.</li>
<li>Each <code>Unlock Type</code> must denote a <em>Signature Unlock Block</em> or a <em>Reference Unlock Block</em>.</li>
<li>Each <em>Signature Unlock Block</em> must contain an <em>Ed25519 Signature</em>.</li>
<li>Each <em>Signature Unlock Block</em> must be unique.</li>
<li>A <em>Reference Unlock Block</em> at index i must have <code>Reference</code> &lt; i and the unlock block at index <code>Reference</code> must be a <em>Signature Unlock Block</em>.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Transaction Payload</em> must consume the entire byte array of the <code>Payload</code> field of the encapsulating object.</li>
</ul>
<p><sup>1</sup> ensures that serialization of the transaction becomes deterministic, meaning that libraries always produce the same bytes given the logical transaction.</p>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic validation</a></h3>
<p>The Semantic validation of a <em>Transaction Payload</em> is performed when its encapsulating message is confirmed by a milestone. The semantic validity of transactions depends on the order in which they are processed. Thus, it is necessary that all the nodes in the network perform the checks in the same order, no matter the order in which the transactions are received. This is assured by using the White-Flag ordering as described in <a href="https://iotaledger.github.io/protocol-rfcs/0005-white-flag/0005-white-flag.html#deterministically-ordering-the-tangle">RFC-005</a>.</p>
<p>Processing transactions according to the White-Flag ordering enables users to spend UTXOs which are created in the same milestone confirmation cone, as long as the spending transaction comes after the funding transaction in the aforementioned White-Flag order. In this case, it is recommended that users include the <em>Message ID</em> of the funding transaction as a parent of the message containing the spending transaction.</p>
<p>The following criteria defines whether a payload passes the semantic validation:</p>
<ul>
<li>Each input must reference a valid UTXO, i.e. the output referenced by the input's <code>Transaction ID</code> and <code>Transaction Output Index</code> is known (booked) and unspent.</li>
<li>The transaction must spend the entire balance, i.e. the sum of the <code>Amount</code> fields of all the UTXOs referenced by inputs must match the sum of the <code>Amount</code> fields of all outputs.</li>
<li>Each unlock block must be valid with respect to the UTXO referenced by the input of the same index:
<ul>
<li>If it is a <em>Signature Unlock Block</em>:
<ul>
<li>The <code>Signature Type</code> must match the <code>Address Type</code> of the UTXO, </li>
<li>the BLAKE2b-256 hash of <code>Public Key</code> must match the <code>Address</code> of the UTXO and</li>
<li>the <code>Signature</code> field must contain a valid signature for <code>Public Key</code>.</li>
</ul>
</li>
<li>If it is a <em>Reference Unlock Block</em>, the referenced <em>Signature Unlock Block</em> must be valid with respect to the UTXO.</li>
</ul>
</li>
</ul>
<p>If a <em>Transaction Payload</em> passes the semantic validation, its referenced UTXOs must be marked as spent and its new outputs must be created/booked in the ledger. The <em>Message ID</em> of the message encapsulating the processed payload then also becomes part of the input for the White-Flag Merkle tree hash of the confirming milestone (<a href="https://iotaledger.github.io/protocol-rfcs/0012-milestone-merkle-validation/0012-milestone-merkle-validation.html">RFC-0012</a>).</p>
<p>Transactions that do not pass semantic validation are ignored. Their UTXOs are not marked as spent and their outputs are not booked in the ledger.</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="transaction-timestamps"><a class="header" href="#transaction-timestamps">Transaction timestamps</a></h3>
<p>Since transaction timestamps – whether they are signed or not – do not provide any guarantee of correctness, they have been left out of the <em>Transaction Payload</em>. Applications relying on some notion of time for transactions can use the local solidification time or the global timestamp of the confirming milestone (<a href="https://iotaledger.github.io/protocol-rfcs/0019-milestone-payload/0019-milestone-payload.html">RFC-0019</a>).</p>
<h3 id="address-reuse"><a class="header" href="#address-reuse">Address reuse</a></h3>
<p>While, in contrast to Winternitz one-time signatures (W-OTS), producing multiple Ed25519 signatures for the same private key and address does not decrease its security, it still drastically reduces the privacy of users. It is thus considered best practice that applications and services create a new address per deposit to circumvent these privacy issues.</p>
<p>In essence, Ed25519 support allows for smaller transaction sizes and to safely spend funds which were sent to an already used deposit address. Ed25519 addresses are not meant to be used like email addresses. See this <a href="https://en.bitcoin.it/wiki/Address_reuse">Bitcoin wiki article</a> for further information.</p>
<h1 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h1>
<ul>
<li>The new transaction format is the core data type within the IOTA ecosystem. Changing it means that all projects need to accommodate it, including wallets, web services, client libraries and applications using IOTA in general. It is not possible to keep these changes backwards compatible, meaning that all nodes must upgrade to further participate in the network.</li>
<li>Additionally, local snapshots can no longer be represented by a list of addresses and their balances, since the ledger is now made up of the UTXOs on which the actual funds reside. Therefore, local snapshot file schemes have to be adjusted to incorporate the transaction hashes, output indices, and then the destination addresses including the balances.</li>
</ul>
<h1 id="rationale-and-alternatives-5"><a class="header" href="#rationale-and-alternatives-5">Rationale and alternatives</a></h1>
<ul>
<li>Introducing this new transaction structure allows for extensions in the future, to accommodate new requirements. With the support for Ed25519 addresses/signatures, transaction size is drastically reduced and allows for safe re-signing in case of address reuse. Due to the switch to a complete binary transaction, the transaction size is reduced even further, saving network bandwidth and processing time.</li>
<li>Other transaction structures have been considered but they would have misused existing transaction fields to accommodate for new features, instead of putting them into a proper descriptive structure. Additionally, those ideas would not have been safe against replay attacks, which deems reusing the old transaction structure, for example for Ed25519 addresses/signatures, as infeasible.</li>
<li>Not switching to the new transaction structure described in this RFC would have led to more people losing funds because of W-OTS address reuse and it would prevent extending the IOTA protocol further down the line.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>milestone-payload</code></li>
<li>Start date: 2020-07-28</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/19">iotaledger/protocol-rfcs#0019</a></li>
</ul>
<h1 id="summary-6"><a class="header" href="#summary-6">Summary</a></h1>
<p>In IOTA, nodes use the milestones issued by the Coordinator to reach a consensus on which transactions are confirmed. This RFC proposes a milestone payload for the messages described in the IOTA protocol <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html">RFC-0017</a>. It uses Edwards-curve Digital Signature Algorithm (EdDSA) to authenticate the milestones.</p>
<h1 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h1>
<p>In the current IOTA protocol, milestones are authenticated using a ternary Merkle signature scheme. In the Chrysalis update, ternary transactions are replaced with binary messages containing different payload types. In order to address these new requirements, this RFC proposes the use of a dedicated payload type for milestones. It contains the same essential data fields that were previously included in the milestone bundle. Additionally, this document also describes how Ed25519 signatures are used to assure authenticity of the issued milestones. In order to make the management and security of the used private keys easier, simple multisignature features with support for key rotation have been added.</p>
<h1 id="detailed-design-6"><a class="header" href="#detailed-design-6">Detailed design</a></h1>
<p>The <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the <em>Milestone Essence</em>, consisting of the actual milestone information (like its index number or position in the tangle), is signed using the Ed25519 signature scheme as described in the IRTF <a href="https://tools.ietf.org/html/rfc8032">RFC 8032</a>. It uses keys of 32 bytes, while the generated signatures are 64 bytes.</p>
<p>To increase the security of the design, a milestone can (optionally) be independently signed by multiple keys at once. These keys should be operated by detached signature provider services running on independent infrastructure elements. This assist in mitigating the risk of an attacker having access to all the key material necessary for forging milestones. While the Coordinator takes responsibility for forming Milestone Payload Messages, it delegates signing in to these providers through an ad-hoc RPC connector. Mutual authentication should be enforced between the Coordinator and the signature providers: a <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake">client-authenticated TLS handshake</a> scheme is advisable. To increase the flexibility of the mechanism, nodes can be configured to require a quorum of valid signatures to consider a milestone as genuine.</p>
<p>In addition, a key rotation policy can also be enforced by limiting key validity to certain milestone intervals. Accordingly, nodes need to know which public keys are applicable for which milestone index. This can be provided by configuring a list of entries consisting of the following fields:</p>
<ul>
<li><em>Index Range</em> providing the interval of milestone indices for which this entry is valid. The interval must not overlap with any other entry.</li>
<li><em>Applicable Public Keys</em> defining the set of valid public keys.</li>
<li><em>Signature Threshold</em> specifying the minimum number of valid signatures. Must be at least one and not greater than the number of <em>Applicable Public Keys</em>.</li>
</ul>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p>All values are serialized in little-endian encoding. The serialized form of the milestone is deterministic, meaning the same logical milestone always results in the same serialized byte sequence.</p>
<p>The following table structure describes the entirety of a <em>Milestone Payload</em> in its serialized form (<a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html#data-types">RFC-0017, Data types</a>):</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Payload Type</td>
    <td>uint32</td>
    <td>Set to <strong>value 1</strong> to denote a <i>Milestone Payload</i>.</td>
  </tr>
  <tr>
    <td valign="top">Essence <code>oneOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Milestone Essence</summary>
        <blockquote>Describes the signed part of a <i>Milestone Payload</i>.</blockquote>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Index Number</td>
            <td>uint32</td>
            <td>The index number of the milestone.</td>
          </tr>
          <tr>
            <td>Timestamp</td>
            <td>uint64</td>
            <td>The Unix time (seconds since Unix epoch) at which the milestone was issued.</td>
          </tr>
          <tr>
            <td>Parents Count</td>
            <td>uint8</td>
            <td>The number of messages that are directly approved.</td>
          </tr>
          <tr>
            <td valign="top">Parents <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Parent</summary>
                <blockquote>
                  References another directly approved message.
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Message ID</td>
                    <td>ByteArray[32]</td>
                    <td>The Message ID of the parent.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Inclusion Merkle Root</td>
            <td>ByteArray[32]</td>
            <td>The Merkle tree hash (BLAKE2b-256) of the message IDs of all the not-ignored state-mutating transaction payloads referenced by the milestone (<a href="https://iotaledger.github.io/protocol-rfcs/0012-milestone-merkle-validation/0012-milestone-merkle-validation.html">RFC-0012</a>).</td>
          </tr>
          <tr>
            <td>Next PoW Score</td>
            <td>uint32</td>
            <td>The new PoW score all messages should adhere to. If 0 then the PoW score should not change.</td>
          </tr>
          <tr>
            <td>Next PoW Score Milestone Index</td>
            <td>uint32</td>
            <td>The index of the first milestone that will require a new minimal pow score for applying transactions. This field comes into effect only if the <code>Next PoW Score</code> field is not 0.</td>
          </tr>
          <tr>
            <td>Keys Count</td>
            <td>uint8</td>
            <td>Number of public keys entries.</td>
          </tr>
          <tr>
            <td valign="top">Keys <code>anyOf</code></td>
            <td colspan="2">
              <details>
                <summary>Ed25519 Public Key</summary>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Public Key</td>
                    <td>ByteArray[32]</td>
                    <td>The public key of the Ed25519 keypair which is used to verify the correspondig signature.</td>
                  </tr>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td>Payload Length</td>
            <td>uint32</td>
            <td>The length in bytes of the optional payload.</td>
          </tr>
          <tr>
            <td valign="top">Payload <code>optOneOf</code></td>
            <td colspan="2">
              <details>
                <summary>Generic Payload</summary>
                <blockquote>
                  An outline of a generic payload
                </blockquote>
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Payload Type</td>
                    <td>uint32</td>
                    <td>
                      The type of the payload. It will instruct the node how to parse the fields that follow.
                    </td>
                  </tr>
                  <tr>
                    <td>Data Fields</td>
                    <td>ANY</td>
                    <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                  </tr>
                </table>
              </details>
          <tr>
        </table>
      </details>
    </td>
  </tr>
  <tr>
    <td>Signatures Count</td>
    <td>uint8</td>
    <td>Number of signature entries. The number must match the field <code>Keys Count</code>.</td>
  </tr>
  <tr>
    <td valign="top">Signatures <code>anyOf</code></td>
    <td colspan="2">
      <details open="true">
        <summary>Raw Ed25519 Signature</summary>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Signature</td>
            <td>ByteArray[64]</td>
            <td>The Ed25519 signature signing the BLAKE2b-256 hash of the serialized <i>Milestone Essence</i>. The signatures must be in the same order as the specified public keys.</td>
          </tr>
        </table>
      </details>
    </td>
  </tr>
</table>
<h2 id="generation"><a class="header" href="#generation">Generation</a></h2>
<ul>
<li>Generate a new <em>Milestone Essence</em> corresponding to the Coordinator milestone.</li>
<li>Transmit the serialized <em>Milestone Essence</em> to the corresponding number of signature service providers.
<ul>
<li>The signature provider service will sign the received serialized bytes as-is.</li>
<li>The signature provider will serialize the signature bytes and return them to the Coordinator.</li>
</ul>
</li>
<li>Fill the <code>Signatures</code> field of the milestone payload with the received signature bytes.</li>
<li>Generate a <em>Message</em> as defined in <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html">RFC-0017</a> using the same <code>Parents</code> as in the created <em>Milestone Payload</em>.</li>
</ul>
<h2 id="syntactical-validation"><a class="header" href="#syntactical-validation">Syntactical validation</a></h2>
<ul>
<li><code>Parents</code> of the payload must match <code>Parents</code> of the encapsulating <em>Message</em>.</li>
<li>PoW score:
<ul>
<li>If <code>Next Pow Score</code> is zero, <code>Next PoW Score Milestone Index</code> must also be zero.</li>
<li>Otherwise <code>Next PoW Score Milestone Index</code> must be larger than <code>Index Number</code>.</li>
</ul>
</li>
<li>Keys:
<ul>
<li><code>Keys Count</code> must be at least the <em>Signature Threshold</em> and at most the number of <em>Applicable Public Keys</em> for the current milestone index.</li>
<li><code>Keys</code> must be sorted in lexicographical order.</li>
<li>Each <code>Public Key</code> must be unique.</li>
<li><code>Keys</code> must form a subset of the <em>Applicable Public Keys</em> for the current milestone index.</li>
</ul>
</li>
<li>Payload (if present):
<ul>
<li><code>Payload Type</code> must match one of the values described under <a href="0019-milestone-payload/0019-milestone-payload.html#payloads">Payloads</a>.</li>
<li><code>Data fields</code> must be correctly parsable in the context of the <code>Payload Type</code>.</li>
<li>The payload itself must pass syntactic validation.</li>
</ul>
</li>
<li>Signatures:
<ul>
<li><code>Signatures Count</code> must match <code>Keys Count</code>.</li>
<li><code>Signature</code> at index i must be valid with respect to the <code>Public Key</code> at the same index.</li>
</ul>
</li>
<li>Given the type and length information, the <em>Milestone Payload</em> must consume the entire byte array of the <code>Payload</code> field of the <em>Message</em>.</li>
</ul>
<h3 id="payloads-1"><a class="header" href="#payloads-1">Payloads</a></h3>
<p>The  <em>Milestone Payload</em> itself can contain another payload as described in general in <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html">RFC-0017</a>. The following table lists all the payloads types that can be nested inside a <em>Milestone Payload</em> as well as links to the corresponding specification:</p>
<table><thead><tr><th>Payload Name</th><th>Type Value</th><th>RFC</th></tr></thead><tbody>
<tr><td>Receipts</td><td>4</td><td><a href="https://github.com/luca-moser/protocol-rfcs/blob/rfc/wotsicide/text/0035-wotsicide/0035-wotsicide.md#receipts">RFC-0035 (draft)</a></td></tr>
</tbody></table>
<h1 id="rationale-and-alternatives-6"><a class="header" href="#rationale-and-alternatives-6">Rationale and alternatives</a></h1>
<ul>
<li>Instead of using EdDSA we could have chosen ECDSA. Both algorithms are well supported and widespread. However, signing with ECDSA requires fresh randomness while EdDSA does not. Especially in the case of milestones where essences are signed many times using the same key, this is a crucial property.</li>
<li>Due to the layered design of messages and payloads, it is practically not possible to prevent reattachments of <em>Milestone Payloads</em>. Hence, this payload has been designed in a way to be independent from the message it is contained in. A milestone should be considered as a virtual marker (referencing <code>Parents</code>) rather than an actual message in the Tangle. This concept is compatible with reattachments and supports a cleaner separation of the message layers.</li>
<li>Forcing matching <code>Parents</code> in the <em>Milestone Payload</em> and its <em>Message</em> makes it impossible to reattach the same payload at different positions in the Tangle. This does not prevent reattachments in general (a different, valid <code>Nonce</code>, for example would lead to a new Message ID) and it violates a strict separation of payload and message. However, it simplifies milestone processing as the position of the <em>Message</em> will be the same as the possition encoded in the <em>Milestone Payload</em>. Having this clear structural properties seem to be more desirable than a strict separation of layers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>bech32-address-format</code></li>
<li>Start date: 2020-07-28</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/20">iotaledger/protocol-rfcs#0020</a></li>
</ul>
<h1 id="summary-7"><a class="header" href="#summary-7">Summary</a></h1>
<p>This document proposes an extendable address format for the IOTA protocol supporting various signature schemes and address types. It relies on the <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">Bech32</a> format to provide a compact, human-readable encoding with strong error correction guarantees.</p>
<h1 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h1>
<p>With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, IOTA uses Ed25519 to generate digital signatures, in which addresses correspond to a BLAKE2b-256 hash. It is necessary to define a new universal and extendable address format capable of encoding different types of addresses.</p>
<p>The current IOTA protocol relies on Base27 addresses with a truncated Kerl checksum. However, both the character set and the checksum algorithm have limitations: </p>
<ul>
<li>Base27 is designed for ternary and is ill-suited for binary data.</li>
<li>The Kerl hash function also requires ternary input. Further, it is slow and provides no error-detection guarantees.</li>
<li>It does not support the addition of version or type information to distinguish between different kinds of addresses with the same length.</li>
</ul>
<p>All of these points are addressed in the Bech32 format introduced in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>: In addition to the usage of the human-friendly Base32 encoding with an optimized character set, it implements a <a href="https://en.wikipedia.org/wiki/BCH_code">BCH code</a> that <em>guarantees detection</em> of any error affecting at most four characters and has less than a 1 in 10<sup>9</sup> chance of failing to detect more errors.</p>
<p>This RFC proposes a simple and extendable binary serialization for addresses of different types that is then Bech32 encoded to provide a unique appearance for human-facing applications such as wallets. </p>
<h1 id="detailed-design-7"><a class="header" href="#detailed-design-7">Detailed design</a></h1>
<h2 id="binary-serialization"><a class="header" href="#binary-serialization">Binary serialization</a></h2>
<p>The address format uses a simple serialization scheme which consists of two parts:</p>
<ul>
<li>The first byte describes the type of the address.</li>
<li>The remaining bytes contain the type-specific raw address bytes.</li>
</ul>
<p>Currently, only one kind of addresses are supported:</p>
<ul>
<li>Ed25519, where the address consists of the BLAKE2b-256 hash of the Ed25519 public key.</li>
</ul>
<p>They are serialized as follows:</p>
<table><thead><tr><th>Type</th><th>First byte</th><th>Address bytes</th></tr></thead><tbody>
<tr><td>Ed25519</td><td><code>0x00</code></td><td>32 bytes: The BLAKE2b-256 hash of the Ed25519 public key.</td></tr>
</tbody></table>
<h2 id="bech32-for-human-readable-encoding"><a class="header" href="#bech32-for-human-readable-encoding">Bech32 for human-readable encoding</a></h2>
<p>The human-readable encoding of the address is Bech32 (as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173</a>). A Bech32 string is at most 90 characters long and consists of: </p>
<ul>
<li>The <strong>human-readable part</strong> (HRP), which conveys the IOTA protocol and distinguishes between Mainnet (the IOTA token) and Testnet (testing version):
<ul>
<li><code>iota</code> is the human-readable part for Mainnet addresses</li>
<li><code>atoi</code> is the human-readable part for Testnet addresses</li>
</ul>
</li>
<li>The <strong>separator</strong>, which is always <code>1</code>.</li>
<li>The <strong>data part</strong>, which consists of the Base32 encoded serialized address and the 6-character checksum.</li>
</ul>
<p>Hence, Ed25519-based addresses will result in a Bech32 string of 64 characters.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li><strong>Mainnet</strong>
<ul>
<li>Ed25519 compressed public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code>
<ul>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code> </li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string: <code>iota1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6xqgyzyx</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Testnet</strong>
<ul>
<li>Ed25519 compressed public key (32-byte): <code>6f1581709bb7b1ef030d210db18e3b0ba1c776fba65d8cdaad05415142d189f8</code>
<ul>
<li>BLAKE2b-256 hash (32-byte): <code>efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code> </li>
<li>serialized (33-byte): <code>00efdc112efe262b304bcf379b26c31bad029f616ee3ec4aa6345a366e4c9e43a3</code></li>
<li>Bech32 string: <code>atoi1qrhacyfwlcnzkvzteumekfkrrwks98mpdm37cj4xx3drvmjvnep6x8x4r7t</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h1>
<ul>
<li>The new addresses look fundamentally different from the established 81-tryte IOTA addresses. However, since the switch from binary to ternary and Chrysalis in general is a substantial change, this is a very reasonable and desired consequence.</li>
<li>A four character HRP plus one type byte only leaves a maximum of 48 bytes for the actual address. </li>
</ul>
<h1 id="rationale-and-alternatives-7"><a class="header" href="#rationale-and-alternatives-7">Rationale and alternatives</a></h1>
<ul>
<li>There are several ways to convert the binary serialization into a human-readable format, e.g. Base58 or hexadecimal. The Bech32 format, however, offers the best compromise between compactness and error correction guarantees. A more detailed motivation can be found in <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#motivation">BIP-0173 Motivation</a>.</li>
<li>The binary serialization itself must be as compact as possible while still allowing you to distinguish between different address types of the same byte length. As such, the introduction of a version byte offers support for up to 256 different kinds of addresses at only the cost of one single byte.</li>
<li>The HRP of the Bech32 string offers a good opportunity to clearly distinguish IOTA addresses from other Bech32 encoded data. Here, any three or four character ASCII strings can be used. However, selecting <code>iota</code> as well as <code>atoi</code> seems like the most recognizable option.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature name: <code>message-pow</code></li>
<li>Start date: 2020-08-25</li>
<li>RFC PR: <a href="https://github.com/iotaledger/protocol-rfcs/pull/0024">iotaledger/protocol-rfcs#0024</a></li>
</ul>
<h1 id="summary-8"><a class="header" href="#summary-8">Summary</a></h1>
<p>The IOTA protocol uses proof-of-work as a means to rate-limit the network. Currently, the Curl-P-81 trinary hash function is used and is required to provide a hash with the matching number of trailing zero trits to issue a transaction to the Tangle. With <a href="https://roadmap.iota.org/chrysalis">Chrysalis</a>, it will be possible to issue binary messages of arbitrary size. This RFC presents a proposal to adapt the existing PoW mechanism to these new requirements. It aims to be less disruptive to the current PoW mechanism as possible.</p>
<h1 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h1>
<p>In the current IOTA Protocol, each transaction has a fixed size of 8019 trits and is hashed using Curl-P-81 to compute its 243-trit transaction hash, where the PoW's difficulty equals the number of trailing zero trits in that hash.<br>
Unfortunately, the performance of Curl-P-81 is slow, achieving only about 2 MB/s on a single core. This would make the PoW validation a bottleneck, especially for high usage scenarios with larger messages. Thus, this RFC proposes a two-stage approach to speed up the validation process: First, the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash function is used to create a short, fixed length digest of the message. Then, this digest, together with the nonce, is hashed using Curl-P-81. Since the digest only needs to be computed once while iterating over different nonce values, this preserves Curl as the PoW-relevant hash. However, the validation is much faster, as BLAKE2b-256 has a performance of about 1 GB/s and Curl then only needs to be executed for one single 243-trit block of input. Since the input of the final Curl computation is always fixed, parallel Curl variants can be used in this stage to further speed up the validation if necessary.<br>
Furthermore, it is important to note that the time required to do the PoW depends on the PoW difficulty and not on the message length. As such, to treat messages with different lengths differently, we need to weight the PoW difficulty by the message length.</p>
<p>It will be easy to adapt existing hardware and software implementations of the current PoW mechanism to work with the proposed design. Only the input and the position of the nonce in the buffer needs to be adapted. This enables existing Curl projects to continue persisting and also the entire PoW landscape should stay almost the same.</p>
<h1 id="detailed-design-8"><a class="header" href="#detailed-design-8">Detailed design</a></h1>
<p>The PoW score is defined as the average number of iterations required to find the number of trailing zero trits in the hash divided by the message size.</p>
<p>The PoW validation is performed in the following way:</p>
<ul>
<li>Compute the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash of the serialized message (as described in <a href="https://iotaledger.github.io/protocol-rfcs/0017-tangle-message/0017-tangle-message.html">RFC-0017</a>) <em>excluding</em> the 8-byte <code>Nonce</code> field and convert the hash into its 192-trit <code>b1t6</code> encoding. (See <a href="https://iotaledger.github.io/protocol-rfcs/0015-binary-to-ternary-encoding/0015-binary-to-ternary-encoding.html">RFC-0015</a> for a description of the encoding.)</li>
<li>Take the 8-byte <code>Nonce</code> in little-endian representation, convert it into its 48-trit <code>b1t6</code> encoding and append it to the hash trits.</li>
<li>Add a padding of three zero trits to create a 243-trit string.</li>
<li>Compute the Curl-P-81 hash.</li>
<li>Count the number of trailing zero trits in the hash.</li>
<li>Then, the PoW score equals 3<sup>#zeros</sup> / size(message).</li>
</ul>
<p>This can also be summarized with the following pseudocode:</p>
<pre><code>pow_digest ← BLAKE2b-256(serialized message excluding nonce field)
pow_hash ← Curl-P-81(b1t6(pow_digest) || b1t6(nonce) || [0, 0, 0])
pow ← 3**trailing_zeros(pow_hash) / size
</code></pre>
<p>where <code>size</code> is the number of bytes of the full serialized message.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<ul>
<li>Message including nonce (21-byte): <code>48656c6c6f2c20576f726c64215ee6aaaaaaaaaaaa</code></li>
<li>PoW digest (32-byte): <code>511bc81dde11180838c562c82bb35f3223f46061ebde4a955c27b3f489cf1e03</code></li>
<li>Nonce (8-byte): <code>5ee6aaaaaaaaaaaa</code> (12297829382473049694)</li>
<li>Curl input (81-tryte): <code>9C9AYYBATZQAXAH9BBVYQDYYPBDXNDWBHAO9ODPDFZTZTCAWKCLADXO9PWEYCAC9MCAZVXVXVXVXVXVX9</code></li>
<li>PoW hash (81-tryte): <code>DJCAGKILZPLXNXWFTNXFLCHRFVUHHMTPFIOFKQXMGIKITSEVWECMQOKCFXDIIHK9YVHGQICAIVEVDJ999</code></li>
<li>Trailing zeros: 9</li>
<li>PoW score: 3<sup>9</sup> / 21 = 937.2857142857143</li>
</ul>
<h1 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h1>
<ul>
<li>Curl is a ternary hash function that is applied on binary data. This makes it necessary to introduce an additional encoding step. However, the proposed <code>b1t6</code> encoding is reasonably performant. Additionally, hash functions usually contain an encoding step to write the input into their internal state. In that sense, the <code>b1t6</code> encoding is not much different.</li>
<li>One additional trailing zero in the PoW hash effectively allows the message size to be tripled. This could potentially incentivize users to add otherwise unnecessary data, when the PoW difficulty stays the same. Using a binary hash function instead of Curl would only slightly improve this situation as the allowed message length remains exponential in the difficulty parameter.</li>
</ul>
<h1 id="rationale-and-alternatives-8"><a class="header" href="#rationale-and-alternatives-8">Rationale and alternatives</a></h1>
<p>The premise of this proposal is that the PoW should remain Curl-based to cause the least amount of disruption to the protocol and its established projects. Therefore, other hash functions or PoW algorithms have not been considered. However, modifications of the described calculation are possible:</p>
<ul>
<li>There are several potential encodings for the nonce: E.g. converting its value directly to balanced ternary (the most compact encoding) or using the <code>b1t8</code> encoding. The chosen <code>b1t6</code> encoding achieves a nice balance between compactness and performance. Since it is possible to fit the PoW digest and the <code>b1t6</code> encoded nonce into one Curl block, the simplicity of having only one encoding (for PoW digest and nonce) was preferred over minimal performance improvements other encodings could bring.</li>
<li>Curl can be computed directly on the <code>b1t6</code> encoded message (after an appropriate padding has been added). However, performance analysis of existing node implementation suggests that the Curl computations during the PoW could become critical, especially since parallel Curl implementations would be much more difficult to deploy because of the dynamic message lengths.</li>
<li>BLAKE2b-256 could be replaced with BLAKE2b-512 or any other binary cryptographic hash function. However, a 256-bit digest fits very nicely into exactly one Curl block and since BLAKE2b-256 is also used for the <em>message ID</em>, it is reasonable to also use it for the PoW digest. This reduces the number of required hashing implementations and even allows reusage of intermediate values between the PoW digest and the message ID computation.</li>
</ul>
<p>The PoW score formula 3<sup>#zeros</sup> / size(message) could be replaced with an alternative function to better match the network usage, e.g. in order to penalize longer message more than linearly.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
